/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AsciiMathPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/.pnpm/asciimath-parser@0.2.2/node_modules/asciimath-parser/dist/index.js
var SYMBOLMAP = /* @__PURE__ */ new Map([
  ["alpha", { type: "Const", tex: "\\alpha" }],
  ["beta", { type: "Const", tex: "\\beta" }],
  ["gamma", { type: "Const", tex: "\\gamma" }],
  ["Gamma", { type: "Const", tex: "\\Gamma" }],
  ["delta", { type: "Const", tex: "\\delta" }],
  ["Delta", { type: "Const", tex: "\\Delta" }],
  ["epsi", { type: "Const", tex: "\\varepsilon" }],
  ["epsilon", { type: "Const", tex: "\\epsilon" }],
  ["varepsilon", { type: "Const", tex: "\\varepsilon" }],
  ["zeta", { type: "Const", tex: "\\zeta" }],
  ["eta", { type: "Const", tex: "\\eta" }],
  ["theta", { type: "Const", tex: "\\theta" }],
  ["Theta", { type: "Const", tex: "\\Theta" }],
  ["vartheta", { type: "Const", tex: "\\vartheta" }],
  ["iota", { type: "Const", tex: "\\iota" }],
  ["kappa", { type: "Const", tex: "\\kappa" }],
  ["lambda", { type: "Const", tex: "\\lambda" }],
  ["Lambda", { type: "Const", tex: "\\Lambda" }],
  ["mu", { type: "Const", tex: "\\mu" }],
  ["nu", { type: "Const", tex: "\\nu" }],
  ["xi", { type: "Const", tex: "\\xi" }],
  ["Xi", { type: "Const", tex: "\\Xi" }],
  ["pi", { type: "Const", tex: "\\pi" }],
  ["Pi", { type: "Const", tex: "\\Pi" }],
  ["rho", { type: "Const", tex: "\\rho" }],
  ["sigma", { type: "Const", tex: "\\sigma" }],
  ["Sigma", { type: "Const", tex: "\\Sigma" }],
  ["tau", { type: "Const", tex: "\\tau" }],
  ["upsilon", { type: "Const", tex: "\\upsilon" }],
  ["phi", { type: "Const", tex: "\\phi" }],
  ["varphi", { type: "Const", tex: "\\varphi" }],
  ["Phi", { type: "Const", tex: "\\Phi" }],
  ["chi", { type: "Const", tex: "\\chi" }],
  ["psi", { type: "Const", tex: "\\psi" }],
  ["Psi", { type: "Const", tex: "\\Psi" }],
  ["omega", { type: "Const", tex: "\\omega" }],
  ["Omega", { type: "Const", tex: "\\Omega" }],
  ["***", { type: "Const", tex: "\\star" }],
  ["**", { type: "Const", tex: "\\ast" }],
  ["*", { type: "Const", tex: "\\cdot" }],
  ["//", { type: "Const", tex: "{/}" }],
  ["\\\\", { type: "Const", tex: "\\backslash" }],
  ["setminus", { type: "Const", tex: "\\setminus" }],
  ["xx", { type: "Const", tex: "\\times" }],
  ["|><", { type: "Const", tex: "\\ltimes" }],
  ["><|", { type: "Const", tex: "\\rtimes" }],
  ["|><|", { type: "Const", tex: "\\bowtie" }],
  ["-:", { type: "Const", tex: "\\div" }],
  ["@", { type: "Const", tex: "\\circ" }],
  ["o+", { type: "Const", tex: "\\oplus" }],
  ["ox", { type: "Const", tex: "\\otimes" }],
  ["o.", { type: "Const", tex: "\\odot" }],
  ["sum", { type: "Const", tex: "\\sum" }],
  ["prod", { type: "Const", tex: "\\prod" }],
  ["^^", { type: "Const", tex: "\\wedge" }],
  ["^^^", { type: "Const", tex: "\\bigwedge" }],
  ["vv", { type: "Const", tex: "\\vee" }],
  ["vvv", { type: "Const", tex: "\\bigvee" }],
  ["nn", { type: "Const", tex: "\\cap" }],
  ["nnn", { type: "Const", tex: "\\bigcap" }],
  ["uu", { type: "Const", tex: "\\cup" }],
  ["uuu", { type: "Const", tex: "\\bigcup" }],
  ["!=", { type: "Const", tex: "\\ne" }],
  ["lt", { type: "Const", tex: "<" }],
  ["<=", { type: "Const", tex: "\\leqslant" }],
  ["le", { type: "Const", tex: "\\le" }],
  ["gt", { type: "Const", tex: ">" }],
  [">=", { type: "Const", tex: "\\geqslant" }],
  ["ge", { type: "Const", tex: "\\ge" }],
  ["-<", { type: "Const", tex: "\\prec" }],
  [">-", { type: "Const", tex: "\\succ" }],
  ["-<=", { type: "Const", tex: "\\preceq" }],
  [">-=", { type: "Const", tex: "\\succeq" }],
  ["in", { type: "Const", tex: "\\in" }],
  ["!in", { type: "Const", tex: "\\notin" }],
  ["sub", { type: "Const", tex: "\\subset" }],
  ["sup", { type: "Const", tex: "\\supset" }],
  ["sube", { type: "Const", tex: "\\subseteq" }],
  ["supe", { type: "Const", tex: "\\supseteq" }],
  ["-=", { type: "Const", tex: "\\equiv" }],
  ["~=", { type: "Const", tex: "\\cong" }],
  ["~", { type: "Const", tex: "\\sim" }],
  ["~~", { type: "Const", tex: "\\approx" }],
  ["prop", { type: "Const", tex: "\\propto" }],
  ["complement", { type: "Const", tex: "\\complement" }],
  ["if", { type: "Text", tex: "if\\quad" }],
  ["otherwise", { type: "Text", tex: "otherwise\\quad" }],
  ["and", { type: "Text", tex: " and " }],
  ["or", { type: "Text", tex: " or " }],
  ["not", { type: "Const", tex: "\\neg" }],
  ["=>", { type: "Const", tex: "\\implies" }],
  ["<=>", { type: "Const", tex: "\\iff" }],
  ["iff", { type: "Const", tex: "\\iff" }],
  ["AA", { type: "Const", tex: "\\forall" }],
  ["EE", { type: "Const", tex: "\\exists" }],
  ["_|_", { type: "Const", tex: "\\bot" }],
  ["TT", { type: "Const", tex: "\\top" }],
  ["|--", { type: "Const", tex: "\\vdash" }],
  ["|==", { type: "Const", tex: "\\models" }],
  ["int", { type: "Const", tex: "\\int" }],
  ["oint", { type: "Const", tex: "\\oint" }],
  ["del", { type: "Const", tex: "\\partial" }],
  ["grad", { type: "Const", tex: "\\nabla" }],
  ["+-", { type: "Const", tex: "\\pm" }],
  ["O/", { type: "Const", tex: "\\varnothing" }],
  ["oo", { type: "Const", tex: "\\infty" }],
  ["aleph", { type: "Const", tex: "\\aleph" }],
  ["...", { type: "Const", tex: "\\ldots" }],
  [":.", { type: "Const", tex: "\\therefore" }],
  [":'", { type: "Const", tex: "\\because" }],
  ["/_", { type: "Const", tex: "\\angle" }],
  ["/_\\", { type: "Const", tex: "\\triangle" }],
  ["quad", { type: "Const", tex: "\\quad" }],
  ["qquad", { type: "Const", tex: "\\qquad" }],
  ["cdots", { type: "Const", tex: "\\cdots" }],
  ["vdots", { type: "Const", tex: "\\vdots" }],
  ["ddots", { type: "Const", tex: "\\ddots" }],
  ["diamond", { type: "Const", tex: "\\diamond" }],
  ["Lap", { type: "Const", tex: "\\mathscr{L}" }],
  ["square", { type: "Const", tex: "\\square" }],
  ["|__", { type: "LParen", tex: "\\lfloor" }],
  ["__|", { type: "RParen", tex: "\\rfloor" }],
  ["|~", { type: "LParen", tex: "\\lceil" }],
  ["~|", { type: "RParen", tex: "\\rceil" }],
  ["CC", { type: "Const", tex: "\\mathbb{C}" }],
  ["NN", { type: "Const", tex: "\\mathbb{N}" }],
  ["QQ", { type: "Const", tex: "\\mathbb{QQ}" }],
  ["RR", { type: "Const", tex: "\\mathbb{R}" }],
  ["ZZ", { type: "Const", tex: "\\mathbb{Z}" }],
  ["'", { type: "Const", tex: "^{\\prime}" }],
  ["''", { type: "Const", tex: "^{\\prime\\prime}" }],
  ["'''", { type: "Const", tex: "^{\\prime\\prime\\prime}" }],
  ["lim", { type: "Const", tex: "\\lim" }],
  ["sin", { type: "Const", tex: "\\sin" }],
  ["cos", { type: "Const", tex: "\\cos" }],
  ["tan", { type: "Const", tex: "\\tan" }],
  ["sinh", { type: "Const", tex: "\\sinh" }],
  ["cosh", { type: "Const", tex: "\\cosh" }],
  ["tanh", { type: "Const", tex: "\\tanh" }],
  ["cot", { type: "Const", tex: "\\cot" }],
  ["sec", { type: "Const", tex: "\\sec" }],
  ["csc", { type: "Const", tex: "\\csc" }],
  ["arcsin", { type: "Const", tex: "\\arcsin" }],
  ["arccos", { type: "Const", tex: "\\arccos" }],
  ["arctan", { type: "Const", tex: "\\arctan" }],
  ["coth", { type: "Const", tex: "\\coth" }],
  ["sech", { type: "Const", tex: "\\sech" }],
  ["csch", { type: "Const", tex: "\\csch" }],
  ["exp", { type: "Const", tex: "\\exp" }],
  ["log", { type: "Const", tex: "\\log" }],
  ["ln", { type: "Const", tex: "\\ln" }],
  ["det", { type: "Const", tex: "\\det" }],
  ["dim", { type: "Const", tex: "\\dim" }],
  ["gcd", { type: "Const", tex: "\\gcd" }],
  ["lcm", { type: "Text", tex: "lcm" }],
  ["min", { type: "Const", tex: "\\min" }],
  ["max", { type: "Const", tex: "\\max" }],
  ["Sup", { type: "Text", tex: "sup" }],
  ["inf", { type: "Const", tex: "\\inf" }],
  ["mod", { type: "Text", tex: "mod" }],
  ["sgn", { type: "Text", tex: "sgn" }],
  ["abs", { type: "OperatorA", tex: "\\left|$1\\right|" }],
  ["norm", { type: "OperatorA", tex: "\\left\\|$1\\right\\|" }],
  ["floor", { type: "OperatorA", tex: "\\left\\lfloor$1\\right\\rfloor" }],
  ["ceil", { type: "OperatorA", tex: "\\left\\lceil$1\\right\\rceil" }],
  ["uarr", { type: "Const", tex: "\\uparrow" }],
  ["uparrow", { type: "Const", tex: "\\uparrow" }],
  ["darr", { type: "Const", tex: "\\downarrow" }],
  ["downarrow", { type: "Const", tex: "\\downarrow" }],
  ["rarr", { type: "Const", tex: "\\rightarrow" }],
  ["rightarrow", { type: "Const", tex: "\\rightarrow" }],
  ["to", { type: "Const", tex: "\\to" }],
  ["->", { type: "Const", tex: "\\to" }],
  [">->", { type: "Const", tex: "\\rightarrowtail" }],
  ["->>", { type: "Const", tex: "\\twoheadrightarrow" }],
  [">->>", { type: "Const", tex: "\\twoheadrightarrowtail" }],
  ["|->", { type: "Const", tex: "\\mapsto" }],
  ["larr", { type: "Const", tex: "\\leftarrow" }],
  ["leftarrow", { type: "Const", tex: "\\leftarrow" }],
  ["harr", { type: "Const", tex: "\\leftrightarrow" }],
  ["rArr", { type: "Const", tex: "\\Rightarrow" }],
  ["lArr", { type: "Const", tex: "\\Leftarrow" }],
  ["hArr", { type: "Const", tex: "\\Leftrightarrow" }],
  ["curvArrLt", { type: "Const", tex: "\\curvearrowleft" }],
  ["curvArrRt", { type: "Const", tex: "\\curvearrowright" }],
  ["circArrLt", { type: "Const", tex: "\\circlearrowleft" }],
  ["circArrRt", { type: "Const", tex: "\\circlearrowright" }],
  ["sqrt", { type: "OperatorA", tex: "\\sqrt{ $1 }" }],
  ["root", { type: "OperatorOAB", tex: "\\sqrt[ $1 ]{ $2 }" }],
  ["frac", { type: "OperatorOAB", tex: "\\frac{ $1 }{ $2 }" }],
  ["/", { type: "OperatorAOB", tex: "\\frac{ $1 }{ $2 }" }],
  ["_", { type: "OperatorSup", tex: "_{ $1 }" }],
  ["^", { type: "OperatorSup", tex: "^{ $1 }" }],
  ["stackrel", { type: "OperatorOAB", tex: "\\stackrel{ $1 }{ $2 }" }],
  ["overset", { type: "OperatorOAB", tex: "\\overset{ $1 }{ $2 }" }],
  ["underset", { type: "OperatorOAB", tex: "\\underset{ $1 }{ $2 }" }],
  ["hat", { type: "OperatorA", tex: "\\hat{ $1 }" }],
  ["widehat", { type: "OperatorA", tex: "\\widehat{ $1 }" }],
  ["arc", { type: "OperatorA", tex: "\\stackrel{\\frown}{ $1 }" }],
  ["bar", { type: "OperatorA", tex: "\\bar{ $1 }" }],
  ["vec", { type: "OperatorA", tex: "\\vec{ $1 }" }],
  ["tilde", { type: "OperatorA", tex: "\\tilde{ $1 }" }],
  ["dot", { type: "OperatorA", tex: "\\dot{ $1 }" }],
  ["ddot", { type: "OperatorA", tex: "\\ddot{ $1 }" }],
  ["ul", { type: "OperatorA", tex: "\\underline{ $1 }" }],
  ["underbrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }],
  ["overbrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }],
  ["color", { type: "OperatorOAB", tex: "\\color{ $1 }{ $2 }" }],
  ["phantom", { type: "OperatorA", tex: "\\phantom{ $1 }" }],
  ["text", { type: "OperatorA", tex: "\\text{ $1 }" }],
  ["mbox", { type: "OperatorA", tex: "\\mbox{ $1 }" }],
  ["op", { type: "OperatorA", tex: "\\operatorname{ $1 }" }],
  ["cancel", { type: "OperatorA", tex: "\\cancel{ $1 }" }],
  ["bb", { type: "OperatorA", tex: "\\mathbf{ $1 }" }],
  ["mathbf", { type: "OperatorA", tex: "\\mathbf{ $1 }" }],
  ["sf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }],
  ["mathsf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }],
  ["bbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }],
  ["mathbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }],
  ["cc", { type: "OperatorA", tex: "\\mathcal{ $1 }" }],
  ["mathcal", { type: "OperatorA", tex: "\\mathcal{ $1 }" }],
  ["tt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }],
  ["mathtt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }],
  ["fr", { type: "OperatorA", tex: "\\mathfrak{ $1 }" }],
  ["bm", { type: "OperatorA", tex: "\\boldsymbol{ $1 }" }],
  ["rm", { type: "OperatorA", tex: "\\mathrm{ $1 }" }],
  ["iint", { type: "Const", tex: "\\iint" }],
  ["iiint", { type: "Const", tex: "\\iiint" }],
  ["oiint", { type: "Const", tex: "\u222F" }],
  ["oiiint", { type: "Const", tex: "\u2230" }],
  ["laplace", { type: "Const", tex: "\\Delta" }],
  ["==", { type: "OperatorOptionalTwoParams", tex: "\\xlongequal[ $2 ]{ $1 }" }],
  ["||", { type: "Const", tex: "\\Vert" }],
  ["!||", { type: "Const", tex: "\u2226" }],
  ["S=", { type: "Const", tex: "\u224C" }],
  ["S~", { type: "Const", tex: "\u223D" }],
  ["!-=", { type: "Const", tex: "\\not\\equiv" }],
  ["!|", { type: "Const", tex: "\u2224" }],
  ["!", { type: "OperatorAO", tex: "!" }],
  ["!!", { type: "OperatorAO", tex: "!!" }],
  ["!sube", { type: "Const", tex: "\\not\\sube" }],
  ["!supe", { type: "Const", tex: "\\not\\supe" }],
  ["subne", { type: "Const", tex: "\u228A" }],
  ["supne", { type: "Const", tex: "\u228B" }],
  ["lhd", { type: "Const", tex: "\\lhd" }],
  ["rhd", { type: "Const", tex: "\\rhd" }],
  ["normal", { type: "Const", tex: "\\unlhd" }],
  ["rnormal", { type: "Const", tex: "\\unrhd" }],
  ["(", { type: "LParen", tex: "(" }],
  [")", { type: "RParen", tex: ")" }],
  ["[", { type: "LParen", tex: "[" }],
  ["]", { type: "RParen", tex: "]" }],
  ["{", { type: "LParen", tex: "\\lbrace" }],
  ["}", { type: "RParen", tex: "\\rbrace" }],
  ["(:", { type: "LParen", tex: "\\langle" }],
  [":)", { type: "RParen", tex: "\\rangle" }],
  ["{:", { type: "LParen", tex: "." }],
  [":}", { type: "RParen", tex: "." }],
  ["|", { type: "Paren", tex: "|" }],
  ["&", { type: "Align", tex: "&" }],
  [",", { type: "Split", tex: "," }],
  [";", { type: "Split", tex: ";" }]
]);
function createRootNode() {
  return {
    type: "Root",
    body: []
  };
}
function createConstNode(arg) {
  if (typeof arg === "undefined") {
    return {
      type: "Const",
      value: "",
      tex: ""
    };
  }
  if (typeof arg === "string") {
    return {
      type: "Const",
      value: arg,
      tex: arg
    };
  }
  return {
    type: "Const",
    value: arg.value,
    tex: arg.type === "Text" ? `\\text{${arg.tex}}` : arg.tex
  };
}
function createFlatNode() {
  return {
    type: "Flat",
    body: []
  };
}
function createMatrixNode() {
  return {
    type: "Matrix",
    params: [],
    lparen: ".",
    rparen: ".",
    alignment: "Center",
    dividerIndices: []
  };
}
function createParamOneNode() {
  return {
    type: "ParamOne",
    tex: "",
    params: createFlatNode()
  };
}
function createParamTwoNode() {
  return {
    type: "ParamTwo",
    tex: "",
    params: [createFlatNode(), createFlatNode()]
  };
}
function createParenOfFlatNodeFrom(token, left) {
  return { type: "Const", value: token.value, tex: `\\${left ? "left" : "right"}${token.tex}` };
}
function readParenedExpression2(tokens, current) {
  let token = tokens[current];
  let semiIndex = -1;
  let closingIndex = -1;
  const stack = [];
  for (let i = current + 1; i < tokens.length; i++) {
    if (tokens[i].type === "LParen") {
      stack.push("");
      continue;
    }
    if (stack.length === 0) {
      if (tokens[i].value === ";") {
        if (semiIndex === -1)
          semiIndex = i;
      } else if (tokens[i].type === "RParen") {
        if (closingIndex === -1)
          closingIndex = i;
      }
      if (semiIndex !== -1 && closingIndex !== -1)
        break;
    } else {
      if (tokens[i].type === "RParen")
        stack.pop();
    }
  }
  if (closingIndex === -1) {
    const node = createFlatNode();
    node.body.push({ type: "Const", value: token.value, tex: `\\left${token.tex}` });
    current++;
    while (current < tokens.length) {
      const walkRes = walk(tokens, current);
      current = walkRes.current;
      node.body.push(walkRes.node);
    }
    node.body.push({ type: "Const", value: token.value, tex: "\\right." });
    return { node, current };
  } else {
    if (semiIndex === -1) {
      const node = createFlatNode();
      node.body.push(createParenOfFlatNodeFrom(token, true));
      current++;
      while (current < closingIndex) {
        const walkRes = walk(tokens, current);
        current = walkRes.current;
        node.body.push(walkRes.node);
      }
      token = tokens[current];
      current++;
      node.body.push(createParenOfFlatNodeFrom(token, false));
      if (node.body[0].value === "{:" && node.body[node.body.length - 1].value === ":}") {
        node.body[0].tex = "{";
        node.body[node.body.length - 1].tex = "}";
      }
      return { node, current };
    } else {
      const node = createMatrixNode();
      const dividerIndices = /* @__PURE__ */ new Set();
      node.lparen = `\\left${token.tex}`;
      token = tokens[++current];
      let tempArr = [];
      let tempNode = null;
      while (current < closingIndex) {
        if (token.type === "Split") {
          if (token.value === ",") {
            if (tempNode) {
              tempArr.push(tempNode);
              tempNode = null;
            } else {
              tempArr.push(createConstNode());
            }
          } else if (token.value === ";") {
            if (tempNode) {
              tempArr.push(tempNode);
              tempNode = null;
            }
            node.params.push(tempArr);
            tempArr = [];
          }
          token = tokens[++current];
          continue;
        } else if (token.type === "Paren") {
          if (tempNode) {
            tempArr.push(tempNode);
            tempNode = null;
          }
          dividerIndices.add(tempArr.length);
          token = tokens[++current];
          continue;
        }
        tempNode = createFlatNode();
        token = tokens[current];
        while (current < closingIndex && token.type !== "Split" && token.type !== "Paren") {
          const walkRes = walk(tokens, current);
          current = walkRes.current;
          tempNode.body.push(walkRes.node);
          token = tokens[current];
        }
      }
      if (tempNode) {
        tempArr.push(tempNode);
        tempNode = null;
      }
      if (tempArr.length > 0) {
        node.params.push(tempArr);
        tempArr = [];
      }
      node.dividerIndices = Array.from(dividerIndices).sort((a, b) => a - b);
      token = tokens[current];
      if (current < tokens.length) {
        current++;
        node.rparen = `\\right${token.tex}`;
        if (token.value === ":}")
          node.alignment = "Left";
      } else {
        node.rparen = "\\right.";
      }
      return { node, current };
    }
  }
}
function findTargetIndices(arr, start, end) {
  let semiIndex = -1;
  let barIndex = -1;
  const stack = [];
  for (let i = start; i < end; i++) {
    if (arr[i].type === "LParen") {
      stack.push("");
      continue;
    }
    if (stack.length > 0 && arr[i].type === "RParen") {
      stack.pop();
      continue;
    }
    if (stack.length > 0)
      continue;
    if (arr[i].type === "RParen")
      break;
    if (arr[i].value === ";") {
      if (semiIndex === -1)
        semiIndex = i;
    } else if (arr[i].value === "|") {
      if (barIndex === -1)
        barIndex = i;
    }
    if (semiIndex !== -1 && barIndex !== -1)
      break;
  }
  return { semiIndex, barIndex };
}
function readBarStartedExpressions(tokens, current) {
  let token = tokens[current];
  if (token.type === "Paren") {
    const { semiIndex, barIndex } = findTargetIndices(tokens, current + 1, tokens.length);
    if (barIndex === -1) {
      return {
        current: current + 1,
        node: {
          type: "Const",
          value: "|",
          tex: "\\mid"
        }
      };
    }
    if (semiIndex === -1 || semiIndex > barIndex) {
      const node2 = createFlatNode();
      current++;
      node2.body.push(createConstNode("\\left|"));
      while (current < barIndex) {
        const walkRes = walk(tokens, current);
        current = walkRes.current;
        node2.body.push(walkRes.node);
      }
      node2.body.push(createConstNode("\\right|"));
      current = barIndex + 1;
      return { current, node: node2 };
    }
    const node = createMatrixNode();
    node.lparen = "\\left|";
    node.rparen = "\\right|";
    token = tokens[++current];
    let tempArr = [];
    let tempNode = null;
    while (current < barIndex) {
      if (token.type === "Split") {
        switch (token.value) {
          case ",": {
            if (tempNode) {
              tempArr.push(tempNode);
              tempNode = null;
            }
            break;
          }
          case ";": {
            if (tempNode) {
              tempArr.push(tempNode);
              tempNode = null;
            }
            node.params.push(tempArr);
            tempArr = [];
            break;
          }
        }
        token = tokens[++current];
        continue;
      }
      tempNode = createFlatNode();
      token = tokens[current];
      while (current < barIndex && token.type !== "Split") {
        const walkRes = walk(tokens, current);
        current = walkRes.current;
        tempNode.body.push(walkRes.node);
        token = tokens[current];
      }
    }
    if (tempNode) {
      tempArr.push(tempNode);
      tempNode = null;
    }
    if (tempArr.length > 0) {
      node.params.push(tempArr);
      tempArr = [];
    }
    current = barIndex + 1;
    return { node, current };
  }
  throw new Error(`Unmatched token in \`readBarStartedExpressions\`, ${token.value}`);
}
function removeParenOfFlatExpr(node) {
  const first = node.body[0];
  const last = node.body[node.body.length - 1];
  if (first.type === "Const" && last.type === "Const" && first.value === "(" && last.value === ")") {
    node.body.pop();
    node.body.shift();
  }
  return node;
}
function lookForwardOperatorOptionalTwoParams(tokens, current, token) {
  let nextToken = tokens[current];
  let p1 = createConstNode();
  let nextShouldBe = "";
  let p1Status = "";
  let p2Status = "";
  if (nextToken.value === "^" || nextToken.value === "_") {
    nextShouldBe = nextToken.value === "^" ? "_" : "^";
    p1Status = nextToken.value;
    current++;
    const walkRes = walk(tokens, current, false);
    if (walkRes.node.type === "Flat")
      walkRes.node = removeParenOfFlatExpr(walkRes.node);
    p1 = walkRes.node;
    current = walkRes.current;
  }
  let p2 = createConstNode();
  if (current < tokens.length) {
    nextToken = tokens[current];
    if (nextToken.value === nextShouldBe) {
      p2Status = nextToken.value;
      current++;
      const walkRes = walk(tokens, current, false);
      if (walkRes.node.type === "Flat")
        walkRes.node = removeParenOfFlatExpr(walkRes.node);
      p2 = walkRes.node;
      current = walkRes.current;
    }
  }
  const node = createParamTwoNode();
  node.tex = token.tex;
  node.params[0] = (() => {
    if (p1Status === "^")
      return p1;
    if (p2Status === "^")
      return p2;
    return createConstNode();
  })();
  node.params[1] = (() => {
    if (p1Status === "_")
      return p1;
    if (p2Status === "_")
      return p2;
    return createConstNode();
  })();
  return { node, current };
}
function walk(tokens, current, watchNext = true) {
  if (current >= tokens.length)
    return { node: createConstNode(), current };
  const token = tokens[current];
  let node;
  switch (token.type) {
    case "Const":
    case "Text":
    case "NumberLiteral":
    case "StringLiteral": {
      current++;
      node = createConstNode(token);
      break;
    }
    case "LParen": {
      const res = readParenedExpression2(tokens, current);
      node = res.node;
      current = res.current;
      break;
    }
    case "Paren": {
      const res = readBarStartedExpressions(tokens, current);
      node = res.node;
      current = res.current;
      break;
    }
    case "OperatorA": {
      node = createParamOneNode();
      node.tex = token.tex;
      current++;
      const walkRes = walk(tokens, current, false);
      current = walkRes.current;
      if (walkRes.node.type === "Flat")
        walkRes.node = removeParenOfFlatExpr(walkRes.node);
      node.params = walkRes.node;
      break;
    }
    case "OperatorOAB": {
      node = createParamTwoNode();
      node.tex = token.tex;
      current++;
      const param0 = walk(tokens, current);
      current = param0.current;
      if (param0.node.type === "Flat")
        param0.node = removeParenOfFlatExpr(param0.node);
      node.params[0] = param0.node;
      const param1 = walk(tokens, current);
      current = param1.current;
      if (param1.node.type === "Flat")
        param1.node = removeParenOfFlatExpr(param1.node);
      node.params[1] = param1.node;
      break;
    }
    case "OperatorOptionalTwoParams": {
      current++;
      if (current >= tokens.length) {
        node = createConstNode(`${token.tex.replace(/[\{\[] \$\d+ [\}\]]/g, "")}{}`);
        break;
      }
      const res = lookForwardOperatorOptionalTwoParams(tokens, current, token);
      current = res.current;
      node = res.node;
      break;
    }
    case "Split":
    case "Align": {
      current++;
      node = createConstNode(token);
      break;
    }
    case "RParen": {
      current++;
      node = createConstNode(token);
      break;
    }
    default: {
      throw new Error(`Unmatched token in walk ${token.value}`);
    }
  }
  if (current < tokens.length && watchNext) {
    let matched = true;
    while (matched && current < tokens.length) {
      const nextToken = tokens[current];
      switch (nextToken.type) {
        case "OperatorAOB": {
          current++;
          const newNode = createParamTwoNode();
          if (node.type === "Flat")
            node = removeParenOfFlatExpr(node);
          newNode.tex = nextToken.tex;
          newNode.params[0] = node;
          const walkRes = walk(tokens, current);
          current = walkRes.current;
          if (walkRes.node.type === "Flat")
            walkRes.node = removeParenOfFlatExpr(walkRes.node);
          newNode.params[1] = walkRes.node;
          node = newNode;
          break;
        }
        case "OperatorAO": {
          current++;
          const newNode = createFlatNode();
          if (node.type === "Flat")
            newNode.body.push(...node.body);
          else
            newNode.body.push(node);
          newNode.body.push(createConstNode(nextToken));
          node = newNode;
          break;
        }
        case "OperatorSup": {
          current++;
          const newNode = createFlatNode();
          if (node.type === "Flat")
            newNode.body.push(...node.body);
          else
            newNode.body.push(node);
          const supNode = createParamOneNode();
          supNode.tex = nextToken.tex;
          const walkRes = walk(tokens, current, false);
          current = walkRes.current;
          if (walkRes.node.type === "Flat")
            walkRes.node = removeParenOfFlatExpr(walkRes.node);
          supNode.params = walkRes.node;
          newNode.body.push(supNode);
          node = newNode;
          break;
        }
        default: {
          matched = false;
        }
      }
    }
  }
  return { node, current };
}
function parser(tokens) {
  const root = createRootNode();
  let current = 0;
  while (current < tokens.length) {
    const walkRes = walk(tokens, current);
    current = walkRes.current;
    root.body.push(walkRes.node);
  }
  return root;
}
function getMatrixBoundary(node) {
  if (node.alignment === "Left")
    return ["\\begin{matrix*}[l]", "\\end{matrix*}"];
  return ["\\begin{matrix}", "\\end{matrix}"];
}
function getArrayBoundary(node) {
  const div = node.dividerIndices;
  if (div.length) {
    for (let i = div.length - 1; i >= 1; i--)
      div[i] -= div[i - 1];
    let beginArray = "\\begin{array}{";
    for (let i = 0; i < div.length; i++)
      beginArray += `${"".padEnd(div[i], "c")}|`;
    const maxCol = Math.max(...node.params.map((i) => i.length));
    beginArray += `${"".padEnd(maxCol - div[div.length - 1], "c")}}`;
    return [
      beginArray,
      "\\end{array}"
    ];
  }
  return ["", ""];
}
function codegen(node) {
  switch (node.type) {
    case "Const": {
      return node.tex;
    }
    case "Root": {
      let res = node.body.map(codegen).join(" ");
      if (node.body.find((n) => n.type === "Const" && n.value === "&"))
        res = `\\begin{aligned}${res}\\end{aligned}`;
      return res;
    }
    case "Flat": {
      return node.body.map(codegen).join(" ");
    }
    case "Matrix": {
      const [beginMatrix, endMatrix] = getMatrixBoundary(node);
      const [arrayBegin, arrayEnd] = getArrayBoundary(node);
      return [
        node.lparen,
        beginMatrix,
        arrayBegin,
        node.params.map((i) => i.map(codegen).join("&")).join("\\\\"),
        arrayEnd,
        endMatrix,
        node.rparen
      ].join(" ");
    }
    case "ParamOne": {
      return node.tex.replace("$1", codegen(node.params));
    }
    case "ParamTwo": {
      return node.tex.replace("$1", codegen(node.params[0])).replace("$2", codegen(node.params[1]));
    }
  }
}
var NUMBERPATTERN = /[0-9]/;
var STRINGPATTERN = /\S/;
var Trie = class {
  constructor(nodes) {
    __publicField(this, "_root");
    __publicField(this, "_char_to_index", /* @__PURE__ */ new Map());
    __publicField(this, "_n");
    if (nodes.length === 0)
      throw new Error("Cannot create Trie since the length of nodes is 0");
    nodes.forEach((n) => {
      if (n.length !== 1)
        throw new Error(`Value \`${n}\` is invalid, the length of char must be 1`);
    });
    const dedupped = Array.from(new Set(nodes));
    this._n = dedupped.length;
    this._root = new TrieNode(this._n);
    dedupped.forEach((ch, i) => {
      this._char_to_index.set(ch, i);
    });
  }
  c2i(key) {
    return this._char_to_index.get(key);
  }
  insert(key) {
    if (key.length === 0)
      return;
    let root = this._root;
    [...key].forEach((ch, i) => {
      const idx = this.c2i(ch);
      if (typeof idx === "undefined")
        throw new Error(`key \`${ch}\` not in key set`);
      if (root._nextNode[idx] === null)
        root._nextNode[idx] = new TrieNode(this._n);
      root = root._nextNode[idx];
      if (i === key.length - 1)
        root._end = true;
    });
  }
  search(word) {
    if (!this._root._nextNode.find((i2) => i2 !== null) || word.length === 0)
      return false;
    let root = this._root;
    let i = 0;
    for (; i < word.length; i++) {
      const ch = word[i];
      const idx = this.c2i(ch);
      if (typeof idx === "undefined")
        throw new Error(`key \`${ch}\` not in key set`);
      if (root._nextNode[idx] === null)
        return false;
      root = root._nextNode[idx];
    }
    if (i === word.length)
      return true;
    return false;
  }
  tryParsing(word, start = 0) {
    let value = "";
    let root = this._root;
    let isKeyWord = false;
    let current = start;
    for (; current < word.length; current++) {
      const ch = word[current];
      const idx = this.c2i(ch);
      if (typeof idx === "undefined")
        break;
      if (root._nextNode[idx] === null)
        break;
      value += ch;
      root = root._nextNode[idx];
      isKeyWord = root._end;
    }
    const ret = (() => {
      if (isKeyWord)
        return SYMBOLMAP.get(value);
      return { tex: value, type: "StringLiteral" };
    })();
    return { value, isKeyWord, current, ...ret };
  }
  tryParsingNumber(word, current) {
    let ch = word[current];
    let value = "";
    while (NUMBERPATTERN.test(ch) && current < word.length) {
      value += ch;
      ch = word[++current];
    }
    return { value, isKeyWord: false, current, tex: value, type: "NumberLiteral" };
  }
  tryParsingString(word, current) {
    let ch = word[current];
    let value = "";
    while (STRINGPATTERN.test(ch) && current < word.length) {
      const idx = this.c2i(ch);
      if (typeof idx !== "undefined" && this._root._nextNode[idx] !== null)
        break;
      value += ch;
      ch = word[++current];
    }
    return { value, isKeyWord: false, current, tex: value, type: "StringLiteral" };
  }
  tryParsingNewLines(word, current) {
    let ch = word[current];
    let value = "";
    while (/\n/.test(ch) && current < word.length) {
      value += ch;
      ch = word[++current];
    }
    if (value.length >= 2)
      return { value, isKeyWord: true, current, tex: "\\\\", type: "Align" };
    else
      return { value: "", isKeyWord: false, current, tex: "", type: "None" };
  }
  tryParsingText(word, current) {
    let ch = word[current];
    if (ch === '"') {
      ch = word[++current];
      let value = "";
      while (ch !== '"' && current < word.length) {
        value += ch;
        ch = word[++current];
      }
      if (ch === '"') {
        current++;
        return { value, isKeyWord: false, current, tex: value, type: "Text" };
      }
    }
    return { value: "", isKeyWord: false, current, tex: "", type: "None" };
  }
  tryParsingAll(word) {
    let current = 0;
    const tokens = [];
    let counter = 0;
    while (current < word.length) {
      {
        const t2 = this.tryParsingNewLines(word, current);
        current = t2.current;
        if (t2.value !== "") {
          tokens.push(t2);
          continue;
        }
      }
      if (/\s/.test(word[current])) {
        current++;
        continue;
      }
      const t = this.tryParsing(word, current);
      current = t.current;
      if (t.value !== "") {
        tokens.push(t);
        continue;
      }
      {
        const t2 = this.tryParsingNumber(word, current);
        current = t2.current;
        if (t2.value !== "") {
          tokens.push(t2);
          continue;
        }
      }
      {
        const t2 = this.tryParsingText(word, current);
        current = t2.current;
        if (t2.value !== "") {
          tokens.push(t2);
          continue;
        }
      }
      {
        const t2 = this.tryParsingString(word, current);
        current = t2.current;
        if (t2.value !== "") {
          tokens.push(t2);
          continue;
        }
      }
      counter++;
      if (counter > word.length * 2)
        throw new Error("Oops! There may be an infinity loop");
    }
    return tokens;
  }
};
var TrieNode = class {
  constructor(n) {
    __publicField(this, "_nextNode", []);
    __publicField(this, "_end", false);
    this._nextNode = Array.from({ length: n }, () => null);
  }
};
function createTrie(config = {}) {
  var _a;
  const charset = /* @__PURE__ */ new Set([]);
  (_a = config.extConst) == null ? void 0 : _a.forEach(([k, v]) => {
    SYMBOLMAP.set(k, { type: "Const", tex: v });
  });
  for (const k of SYMBOLMAP.keys())
    k.split("").forEach((i) => charset.add(i));
  const chars = Array.from(charset);
  chars.push(" ");
  const trie = new Trie(chars);
  for (const k of SYMBOLMAP.keys())
    trie.insert(k);
  return trie;
}
function resolveConfig(config) {
  var _a, _b;
  const defaultConfig = {
    display: true,
    extConst: [
      ["dx", "{\\text{d}x}"],
      ["dy", "{\\text{d}y}"],
      ["dz", "{\\text{d}z}"],
      ["dt", "{\\text{d}t}"]
    ],
    replaceBeforeTokenizing: [
      [/part(\^\S*)?\s+(\S+)\s+(\([^)]*\)|\S+)/g, (_match, $1, $2, $3) => {
        if (!$1)
          $1 = "";
        if ($3[0] === "(")
          $3 = $3.slice(1, -1).split(/\s+/).join(" del ");
        return `(del${$1} ${$2})/(del ${$3})`;
      }],
      [
        /&#(x?[0-9a-fA-F]+);/g,
        (_match, $1) => String.fromCodePoint($1[0] === "x" ? `0${$1}` : $1)
      ]
    ]
  };
  if (config == null ? void 0 : config.display)
    defaultConfig.display = config == null ? void 0 : config.display;
  if ((_a = config == null ? void 0 : config.extConst) == null ? void 0 : _a.length)
    defaultConfig.extConst.push(...config.extConst);
  if ((_b = config == null ? void 0 : config.replaceBeforeTokenizing) == null ? void 0 : _b.length)
    defaultConfig.replaceBeforeTokenizing.push(...config.replaceBeforeTokenizing);
  return defaultConfig;
}
var AsciiMath = class {
  constructor(config) {
    __publicField(this, "trie");
    __publicField(this, "display");
    __publicField(this, "replaceLaws");
    const { display, extConst, replaceBeforeTokenizing: replaceBeforeParsing } = resolveConfig(config);
    this.trie = createTrie({ extConst });
    this.display = display;
    this.replaceLaws = replaceBeforeParsing;
  }
  toTex(code) {
    try {
      code = this.replaceLaws.reduce((prev, curLaw) => {
        if (typeof curLaw[1] === "function")
          return prev.replace(curLaw[0], curLaw[1]);
        else
          return prev.replace(curLaw[0], curLaw[1]);
      }, code);
      let res = codegen(parser(this.trie.tryParsingAll(code)));
      if (this.display)
        res = `\\displaystyle{ ${res} }`;
      return res;
    } catch (e) {
      console.error(e);
      return "";
    }
  }
};

// inline.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");

// utils.ts
function normalizeEscape(escape) {
  return escape.replace(/([$^\\.()[\]{}*?|])/g, "\\$1");
}

// inline.ts
var AM = new AsciiMath();
function selectionAndRangeOverlap(selection, rangeFrom, rangeTo) {
  for (const range of selection.ranges) {
    if (range.from <= rangeTo && range.to >= rangeFrom)
      return true;
  }
  return false;
}
function inlineRender(view, plugin) {
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile)
    return;
  const widgets = [];
  const selection = view.state.selection;
  const regex = /.*?_?inline-code_?.*/;
  for (const { from, to } of view.visibleRanges) {
    (0, import_language.syntaxTree)(view.state).iterate({
      from,
      to,
      enter: (node) => {
        const type = node.type;
        if (type.name.includes("formatting"))
          return;
        if (!regex.test(type.name))
          return;
        const start = node.from;
        const end = node.to;
        const { open, close } = plugin.settings.inline;
        if (selectionAndRangeOverlap(selection, start - open.length + 1, end + close.length - 1))
          return;
        const original = view.state.doc.sliceString(start - open.length + 1, end + close.length - 1).trim();
        const regex2 = new RegExp(`^${normalizeEscape(open)}(.*?)${normalizeEscape(close)}$`);
        const matches = original.match(regex2);
        if (!matches)
          return;
        widgets.push(import_view.Decoration.replace({
          widget: new InlineWidget(matches[1], view),
          inclusive: false,
          block: false
        }).range(start - 1, end + 1));
      }
    });
  }
  return import_view.Decoration.set(widgets, true);
}
var InlineWidget = class extends import_view.WidgetType {
  constructor(rawQuery, view) {
    super();
    this.rawQuery = rawQuery;
    this.view = view;
  }
  eq(other) {
    if (other.rawQuery === this.rawQuery)
      return true;
    return false;
  }
  toDOM(view) {
    const tex = AM.toTex(this.rawQuery);
    const mathEl = (0, import_obsidian.renderMath)(tex, false);
    (0, import_obsidian.finishRenderMath)();
    return mathEl;
  }
};
function inlinePlugin(plugin) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      var _a;
      this.decorations = (_a = inlineRender(view, plugin)) != null ? _a : import_view.Decoration.none;
    }
    update(update) {
      var _a;
      if (!update.state.field(import_obsidian.editorLivePreviewField)) {
        this.decorations = import_view.Decoration.none;
        return;
      }
      if (update.docChanged || update.viewportChanged || update.selectionSet)
        this.decorations = (_a = inlineRender(update.view, plugin)) != null ? _a : import_view.Decoration.none;
    }
  }, { decorations: (v) => v.decorations });
}

// main.ts
var DEFAULT_SETTINGS = {
  blockPrefix: ["asciimath", "am"],
  inline: {
    open: "`$",
    close: "$`"
  }
};
function toTex(am, content) {
  const tex = am.toTex(content);
  return tex.replace(/(\{|\})(\1+)/g, (...args) => Array(args[2].length + 1).fill(args[1]).join(" "));
}
var AsciiMathPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.postProcessors = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    await (0, import_obsidian2.loadMathJax)();
    this.AM = new AsciiMath();
    if (!MathJax) {
      console.warn("MathJax was not defined despite loading it.");
      new import_obsidian2.Notice("Error: MathJax was not defined despite loading it!");
      return;
    }
    this.postProcessors = /* @__PURE__ */ new Map();
    this.app.workspace.onLayoutReady(async () => {
      this.settings.blockPrefix.forEach((prefix) => {
        this.registerAsciiMathBlock(prefix);
      });
    });
    this.registerEditorExtension([inlinePlugin(this)]);
    this.registerMarkdownPostProcessor(this.postProcessorInline.bind(this));
    this.addCommand({
      id: "insert-asciimath-block",
      name: "Insert asciimath block",
      editorCallback: (editor, view) => {
        editor.replaceSelection(`\`\`\`${this.settings.blockPrefix[0] || "asciimath"}
${editor.getDoc().getSelection()}
\`\`\``);
        const cursor = editor.getCursor();
        editor.setCursor(cursor.line - 1);
      }
    });
    this.addCommand({
      id: "convert-am-block-into-mathjax-in-current-file",
      name: "Convert asciimath block into mathjax in current file",
      editorCallback: (editor, view) => {
        this.editorTransactionConvertFormula(editor);
      }
    });
    this.addSettingTab(new AsciiMathSettingTab(this.app, this));
    console.log("Obsidian asciimath loaded");
  }
  editorTransactionConvertFormula(editor) {
    const content = editor.getValue();
    const blockReg = new RegExp(`((\`|~){3,})(${this.settings.blockPrefix.join("|")})([\\s\\S]*?)\\n\\1`, "gm");
    const [open, close] = Object.values(this.settings.inline).map(normalizeEscape);
    const inlineReg = new RegExp(`${open}(.*?)${close}`, "g");
    const changes = [];
    try {
      const blockIterator = content.matchAll(blockReg);
      let match;
      while (!(match = blockIterator.next()).done) {
        const index = match.value.index;
        if (typeof index === "undefined")
          throw new Error("Invalid index: while converting block fomula");
        const amContent = match.value[4];
        if (typeof amContent !== "string")
          throw new Error(`Invalid asciimath formula, index: ${index}`);
        const from = editor.offsetToPos(index);
        const to = editor.offsetToPos(index + match.value[0].length);
        changes.push({
          text: `$$
${toTex(this.AM, amContent)}
$$`,
          from,
          to
        });
      }
      const inlineIterator = content.matchAll(inlineReg);
      while (!(match = inlineIterator.next()).done) {
        const index = match.value.index;
        if (typeof index === "undefined")
          throw new Error("Invalid index: while converting inline formula");
        const amContent = match.value[1];
        if (typeof amContent !== "string")
          throw new Error(`Invalid asciimath formula, index: ${index}`);
        const from = editor.offsetToPos(index);
        const to = editor.offsetToPos(index + match.value[0].length);
        changes.push({
          text: `$${toTex(this.AM, amContent)}$`,
          from,
          to
        });
      }
      if (changes.length === 0) {
        new import_obsidian2.Notice("No asciimath formulas converted!");
        return;
      }
      editor.transaction({ changes });
      new import_obsidian2.Notice(`Successfully converted ${changes.length} asciimath formulas!`);
    } catch (e) {
      new import_obsidian2.Notice(String(e));
    }
  }
  registerAsciiMathBlock(prefix) {
    this.postProcessors.set(prefix, this.registerMarkdownCodeBlockProcessor(prefix, (src, el, ctx) => this.postProcessor(prefix, src, el, ctx)));
  }
  async postProcessorInline(el, ctx) {
    const nodeList = el.querySelectorAll("code");
    if (!nodeList.length)
      return;
    for (let i = 0; i < nodeList.length; i++) {
      const node = nodeList.item(i);
      if (node.className.trim())
        continue;
      let { open, close } = this.settings.inline;
      open = open.slice(1);
      close = close.substring(0, close.length - 1);
      const regex = new RegExp(`^${normalizeEscape(open)}(.*?)${normalizeEscape(close)}$`);
      const matches = node.innerText.match(regex);
      if (!matches)
        continue;
      const tex = this.AM.toTex(matches[1]);
      const mathEl = (0, import_obsidian2.renderMath)(tex, false);
      (0, import_obsidian2.finishRenderMath)();
      node.replaceWith(mathEl);
    }
  }
  postProcessor(_prefix, src, el, _) {
    const tex = this.AM.toTex(src);
    const mathEl = (0, import_obsidian2.renderMath)(tex, true);
    el.appendChild(mathEl);
    (0, import_obsidian2.finishRenderMath)();
  }
  onunload() {
    console.log("Obsidian asciimath unloaded");
    this.unregister();
  }
  unregister() {
    this.postProcessors.forEach((value) => {
      import_obsidian2.MarkdownPreviewRenderer.unregisterPostProcessor(value);
    });
    this.postProcessors.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
function validateSettings(settings) {
  if (settings.blockPrefix.length < 1) {
    return {
      isValid: false,
      message: "You should add at least 1 block prefix!"
    };
  }
  const { open, close } = settings.inline;
  if (!open.startsWith("`") || open.length <= 1 || open.startsWith("``")) {
    return {
      isValid: false,
      message: "Invalid inline leading escape!"
    };
  }
  if (!close.endsWith("`") || close.length <= 1 || close.endsWith("``")) {
    return {
      isValid: false,
      message: "Invalid inline trailing escape!"
    };
  }
  return {
    isValid: true,
    message: "OK"
  };
}
var AsciiMathSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for asciimath" });
    new import_obsidian2.Setting(containerEl).setName("Code block prefix aliases").setDesc("Seperate different aliases with comma.").addText((text) => text.setPlaceholder("asciimath, am").setValue(this.plugin.settings.blockPrefix.join(", ")).onChange(async (value) => {
      this.plugin.settings.blockPrefix = value.split(",").map((s) => s.trim()).filter(Boolean);
    }));
    new import_obsidian2.Setting(containerEl).setName("Inline asciimath start").setDesc("The leading escape of the inline asciimath formula. It should starts with **only one backtick**.").addText((text) => text.setPlaceholder("`$").setValue(this.plugin.settings.inline.open).onChange(async (value) => {
      this.plugin.settings.inline.open = value;
    }));
    new import_obsidian2.Setting(containerEl).setName("Inline asciimath end").setDesc("The trailing escape of the inline asciimath formula. It should ends with **only one backtick**.").addText((text) => text.setPlaceholder("$`").setValue(this.plugin.settings.inline.close).onChange(async (value) => {
      this.plugin.settings.inline.close = value;
    }));
    new import_obsidian2.Setting(containerEl).setName("Don't forget to save and reload settings \u2192").addButton((btn) => btn.setButtonText("Save").onClick(async () => {
      const valid = validateSettings(this.plugin.settings);
      if (!valid.isValid) {
        new import_obsidian2.Notice(valid.message);
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      new import_obsidian2.Notice("Asciimath settings reloaded successfully!");
    }));
  }
};
